# Rust学习笔记2

> 参考资料：
>
> - [清华计算机系大一学生2022暑期课程：Rust程序设计训练](https://lab.cs.tsinghua.edu.cn/rust/)
> - [Rust语言圣经(Rust Course)](https://course.rs/about-book.html)
> - [rustlings](https://github.com/rust-lang/rustlings)
>
> 补充笔记 => [基于Rust的内存安全问题探索](./基于Rust的内存安全问题探索.md)

Rust是一门无GC且无需手动内存管理、性能高、工程性强、语言级安全性以及能同时得到工程派和学院派认可的语言。

## 所有权

Q: 垃圾回收的必要性？为啥平常编程感受不到？写了new很少写delete？

A: 平常因为程序结束，操作系统自动回收处理了。但是假设有一个24小时提供服务的程序，如果没有妥善处理垃圾内存，回导致内存被填满，举例new失败等现象。因此GC的机制是很重要的。

Rust所有权 => 安全+性能

### 所有权规则

- Rust中的每个值都有所有者（owner）
- 同一时刻只有一个所有者
- 当所有者失效，值也被丢弃

### 所有权与变量绑定

- 变量绑定拥有数据的所有权
- 如果一个绑定超出作用域，其绑定的数据将被自动释放
  - 对于在堆上分配的数据，这意味着释放空间
  - 栈上就不用管，操作系统自动分配释放

### 移动语义

```rust
let v1 = vec![1,2,3];

//Ownership of the Vec object moves to v2.
let v2 = v1;
println!("{}",v1[2]);//error: yse of moved value `v1`
```

- let v2 = v1;

  - 拷贝数据代价高昂，不希望默认这样做

  - 数据不能有多个所有者

  - 解决方案：把向量的所有权移交给v2，并将v1置为无效状态

- Rust能够在编译时发现这个问题，从而抛出编译错误

- 移动所有权是编译时的语义，不涉及程序运行时的数据移动
- 移动是默认行为(通过赋值)，不需要像C++那样用std::move来显示指定

### 所有权的转移

并不是任何时候都想移交所有权 => 特别是在函数参数这块，如果每次传递参数都要移交所有权，代码会变得十分繁琐，不光要转移出去还要转移回来，如果涉及的变量越多，函数的返回类型就会越长，可以想到这种方法不具有可扩展性。

### 借用

- 与其移交所有权，不如进行借用borrow
- 可以通过对变量取引用来借用比那两种的数据的所有权，此时所有权本身并没有发生变化。
  - 当引用超过作用域，借用也随之结束
  - 原来的变量依然拥有对数据的所有权

带来的问题：会给原来的变量增加限制

Rust规定当一个变量有引用存在时，不能移交它所绑定的数据的所有权，因为所有权移交会导致引用失效。

#### 补充：NLL

非词法生命周期（NLL, non-lexical lifetime）:

- 2018版新特性
- 对象或引用的生命周期取决于控制流图，而不是词法作用域
- 能够使得借用检查更加灵活，便于编写程序

```rust
//eg.1
fn main() {
  let v = vec![1,2,3];
  let v_ref = &v;
  let v_new = v;
}
```

- 如果v_ref存活到函数结尾，以上代码不符合引用存在时不能移交所有权要求,更直观看eg.2，报错。

  ```rust
  //eg.2
  fn main() {
    let v = vec![1,2,3];
    let v_ref = &v;
    let v_new = v;
    println!("{:?}", v_ref);
  }
  ```

- 但是如果只是eg.1三行，鉴于后续没有再使用，v_ref的生命周期可以提前结束，这个编译是能通过的，就是因为NLL这个新特性

### 借用与函数

- 引用默认是不可变的，与变量绑定相同
- 在超过作用域后，借用结束

- 变量可以通过可变引用来进行借用：`&mut Vec<i32>`
- 函数里不能通过解引用然后绑定给变量，这样做会引起数据的所有权转移(同时引用还没有失效)
- Rust在大多数情况下会自动接引用，但是有些情况需要显示解引用
  - 往解引用后的结果里写入内容
  - 其他可能会引起歧义的情况

> 面向编译器编程hhhh

### Copy类型

不是所有类型拷贝开销都很大，比如就一个浮点数，一个整数...

Rust定义了Copy特型(trait)，表示一种类型可以拷贝，而不是用默认的移动语义。

- 通常这样的类型都是轻量级的，拷贝行为是按位进行的
- 大多数基本类型都是Copy类型(i32, f64, char, bool etc)，包括由Copy类型组成的元组
- 包含引用的类型不是Copy类型(eg. Vec, String)，默认是移动语义，可以用clone()显示操作拷贝

### 思考借用规则

思考借用的内在逻辑，体会以下规则：

- 不能在某个对象不存在后继续保留对它的引用
- 一个对象可以同时存在多个不可变引用(&T)
- 或者仅有一个可变引用(&mut T)
- 以上两者不能同时存在

并发的时候体会更加深刻...

### 借用的作用

举个例子，考虑迭代器的场景：在修改集合的同时进行迭代访问会引起迭代器失效

```rust
let mut vs = vec![1,2,3,4];
for v in &vs {
  vs.pop();
  //ERROR: cannot borrow vs as mutable because it is also borrowed as immutable
}
```

- pop需要以可变方式借用vs来修改数据（在这边会隐式创建可变引用，C++可以类比会传*this）
- 但是vs正在以不可变的方式被循环借用

通过借用机制在编译时就避免这样的问题产生，让程序员写没有问题的代码。上述写法在C++中是能通过编译的，但可能导致运行时错误。

>通过借用机制能够在编译时解决大多数的内存安全问题

### 例子：向量的三种迭代

```rust
let mut vs = vec![0,1,2,3,4,5,6];
//Borrow immutably
for v in &vs { //can also write `for v in vs.iter()`
  println!("{}",v);
}

//Borrow mutably
for v in &mut vs { //can also write `for v in vs.iter_mut()`
  *v = *v + 1;
  println!("{}",v);
}

//Take ownership of the whole vector
for v in vs { //can also write `for v in vs.into_iter()`
  println!("{}",v);
}

//`vs` is no longer valid
```

### 切片

- 切片是一种特殊形态的引用，表示引用序列中的一个片段
- 切片构造的语法是 &x[s..t]，其中s和t还可以根据情况省略（&x[s..=t]）
- 可变性以及引用的约束条件对切片同样适用

